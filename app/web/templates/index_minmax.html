{% extends "layout.html" %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-3">
    <h1 class="h4 mb-0">Min-max generation</h1>
</div>

<!-- Buttons -->
<div class="mb-3">
    <a href="{{ url_for('api.new_minmax_stage') }}" class="btn btn-success btn-sm me-2">+ New Min-Max Stage</a>
</div>

<!-- Stage Table For min max generation stages-->
<h2 class="h5 mt-4">Stages</h2>
<table class="table table-sm align-middle">
    <thead>
    <tr>
        <th>Stage Name</th>
        <th class="text-end">Actions</th>
    </tr>
    </thead>
    <tbody>
    {% for stage in config.min_max_stages %}
    <tr>
        <td><strong>{{ stage.name }}</strong></td>
        <td class="text-end">
            <form method="POST"
                  action="{{ url_for('api.minmax_analysis', stage_index=loop.index0) }}"
                  class="d-inline"> {# no .run-stage-form #}
                <button type="submit" class="btn btn-sm btn-outline-success me-1">Analyze</button>
            </form>
            <form method="POST" action="{{ url_for('api.run_min_max_stage', stage_index=loop.index0) }}"
                  class="run-stage-form d-inline" data-index="{{ loop.index0 }}">
                <button type="submit" class="btn btn-sm btn-outline-success me-1">Run</button>
            </form>
            <a href="{{ url_for('api.edit_minmax_stage', stage_index=loop.index0) }}"
               class="btn btn-sm btn-outline-primary me-1">Edit</a>
            <form method="POST" action="{{ url_for('api.delete_minmax_stage', stage_index=loop.index0) }}"
                  onsubmit="return confirm('Delete this stage?');" class="d-inline">
                <button type="submit" class="btn btn-sm btn-outline-danger">Delete</button>
            </form>
        </td>
    </tr>
    {% endfor %}
    </tbody>
</table>
<div id="run-summary" class="mt-3"></div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const runSummary = document.getElementById('run-summary');

  // Handle ANALYZE: fetch the CSV, trigger download, then re-enable the button
  document.querySelectorAll('form:not(.run-stage-form)').forEach(form => {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      const btn = event.submitter;
      const original = btn ? btn.textContent : 'Analyze';

      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Analyzing...';
      }

      try {
        const res = await fetch(form.action, {
          method: 'POST',
          credentials: 'same-origin',
          headers: {
            // helps some backends branch behavior if needed
            'X-Requested-With': 'XMLHttpRequest',
            'Accept': 'text/csv,application/octet-stream'
          },
          // include form data if you ever add inputs
          body: new FormData(form)
        });

        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);

        const ct = res.headers.get('Content-Type') || '';
        // If server returned JSON (e.g., error), surface it and re-enable
        if (ct.includes('application/json')) {
          const data = await res.json();
          const msg = data && (data.error || data.message || JSON.stringify(data));
          alert(`Analyze failed: ${msg}`);
        } else {
          // Assume a file: stream to a blob and download
          const blob = await res.blob();

          // Try to get filename from Content-Disposition
          const cd = res.headers.get('Content-Disposition') || '';
          const match = /filename\*=UTF-8''([^;]+)|filename="?([^"]+)"?/i.exec(cd);
          const filename = decodeURIComponent((match && (match[1] || match[2])) || 'analysis.csv');

          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        }
      } catch (err) {
        alert(`Analyze error: ${err.message}`);
      } finally {
        if (btn) {
          btn.disabled = false;       // <â€” re-enable after download (or error)
          btn.textContent = original; // restore label
        }
      }
    });
  });

  // Existing RUN handler (unchanged)
  document.querySelectorAll('form.run-stage-form').forEach(form => {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      const btn = event.submitter;
      const label = (btn && btn.textContent) ? btn.textContent.trim() : 'Running';
      if (btn) {
        btn.disabled = true;
        btn.textContent = 'Running...';
      }
      runSummary.textContent = `${label}...`;

      try {
        const res = await fetch(form.action, {
          method: 'POST',
          headers: { 'X-Requested-With': 'XMLHttpRequest' },
          credentials: 'same-origin'
        });
        const data = await res.json();

        if (data.success) {
          runSummary.innerHTML = `
            <strong>${label} Summary:</strong><br>
            Value fallbacks: ${data["Value fallbacks"]}<br>
            Bound warnings: ${data["Bound warnings"]}<br>
            Value errors: ${Array.isArray(data["Value errors"]) ? data["Value errors"].length : data["Value errors"]}<br>
            Values ignored: ${data["Values ignored"]}<br>
            Values imported: ${data["Values imported"]}<br>
            Values missing: ${data["Values missing"]}<br>
            Values imputed: ${data["Values imputed"]}<br>
            Duration: ${data["Duration"]}<br>
          `;
        } else {
          const errs = Array.isArray(data.errors) ? data.errors.join(', ') : (data.errors || 'Unknown error');
          runSummary.textContent = `Error: ${errs}`;
        }
      } catch (err) {
        runSummary.textContent = `Error: ${err.message}`;
      } finally {
        if (btn) {
          btn.disabled = false;
          btn.textContent = 'Run';
        }
      }
    });
  });
});
</script>




<!-- Run summary -->

{% include "partials/_run_controls.html" %}
{% endblock %}